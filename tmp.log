[Vython AST]
Tree(Token('RULE', 'file_input'), [Tree(Token('RULE', 'assign_stmt'), [Tree(Token('RULE', 'assign'), [Tree('var', [Tree(Token('RULE', 'name'), [Token('NAME', 'a')])]), Tree(Token('RULE', 'comparison'), [Tree('const_true', []), Tree(Token('RULE', 'comp_op'), [Token('__ANON_23', '!=')]), Tree('const_false', []), Tree(Token('RULE', 'comp_op'), [Token('__ANON_19', '==')]), Tree('const_false', [])])])]), Tree(Token('RULE', 'expr_stmt'), [Tree('funccall', [Tree('var', [Tree(Token('RULE', 'name'), [Token('NAME', 'print')])]), Tree(Token('RULE', 'arguments'), [Tree('var', [Tree(Token('RULE', 'name'), [Token('NAME', 'a')])])])])])])

[Unparse Python AST]
import re

def __vt_init__(self):
    self.vt = []
    cn = self.__class__.__name__
    pattern = '([A-Za-z_0-9]+)_v_([0-9]+)'
    matchRe = re.fullmatch(pattern, cn)
    if matchRe:
        class_name = matchRe[1]
        version_number = matchRe[2]
    else:
        raise TypeError('Inappropriate Class Name')
    self.vt.append((class_name, version_number, False))
    return

def checkCompatibility(left, right):
    return

def insert(self, c, v, b):
    self.vt.append((c, v, b))
    return

def append(left, right):
    left_vt = left.vt
    right_vt = right.vt
    for x in left_vt:
        cx = x[0]
        vx = x[1]
        bx = x[2]
        for y in right_vt:
            cy = y[0]
            vy = y[1]
            by = y[2]
            if cx == cy and vx == vy and (bx == by):
                left_vt.remove(x)
    left.vt = left_vt + right_vt
    return

class Primitive_String_v_0:

    def __init__(self, value):
        self.value = value
        __vt_init__(self)

    def __repr__(self):
        return f'{self.value}'

    def __add__(left, right):
        return left.binary(right, 'add')

    def __eq__(left, right):
        return left.binary(right, 'eq')

    def __ne__(left, right):
        return left.binary(right, 'ne')

    def __lt__(left, right):
        return left.binary(right, 'lt')

    def __gt__(left, right):
        return left.binary(right, 'gt')

    def __le__(left, right):
        return left.binary(right, 'le')

    def __ge__(left, right):
        return left.binary(right, 'ge')

    def __and__(left, right):
        return left.binary(right, 'and')

    def __or__(left, right):
        return left.binary(right, 'or')

    def binary(left, right, op):
        checkCompatibility(left, right)
        match op:
            case 'add':
                result = Primitive_String_v_0(left.value + right.value)
            case 'and':
                result = Primitive_Bool_v_0(left.value & right.value)
            case 'or':
                result = Primitive_Bool_v_0(left.value | right.value)
            case 'eq':
                result = Primitive_Bool_v_0(left.value == right.value)
            case 'ne':
                result = Primitive_Bool_v_0(left.value != right.value)
            case 'lt':
                result = Primitive_Bool_v_0(left.value < right.value)
            case 'gt':
                result = Primitive_Bool_v_0(left.value > right.value)
            case 'le':
                result = Primitive_Bool_v_0(left.value <= right.value)
            case 'ge':
                result = Primitive_Bool_v_0(left.value >= right.value)
        append(result, left)
        append(result, right)
        return result

class Primitive_Number_v_0:

    def __init__(self, value):
        self.value = value
        __vt_init__(self)

    def __repr__(self):
        return f'{self.value}'

    def __add__(left, right):
        return left.binary(right, 'add')

    def __sub__(left, right):
        return left.binary(right, 'sub')

    def __mul__(left, right):
        return left.binary(right, 'mul')

    def __div__(left, right):
        return left.binary(right, 'div')

    def __floordiv__(left, right):
        return left.binary(right, 'floordiv')

    def __mod__(left, right):
        return left.binary(right, 'mod')

    def __eq__(left, right):
        return left.binary(right, 'eq')

    def __ne__(left, right):
        return left.binary(right, 'ne')

    def __lt__(left, right):
        return left.binary(right, 'lt')

    def __gt__(left, right):
        return left.binary(right, 'gt')

    def __le__(left, right):
        return left.binary(right, 'le')

    def __ge__(left, right):
        return left.binary(right, 'ge')

    def __and__(left, right):
        return left.binary(right, 'and')

    def __or__(left, right):
        return left.binary(right, 'or')

    def binary(left, right, op):
        checkCompatibility(left, right)
        match op:
            case 'add':
                result = Primitive_Number_v_0(left.value + right.value)
            case 'sub':
                result = Primitive_Number_v_0(left.value - right.value)
            case 'mul':
                result = Primitive_Number_v_0(left.value * right.value)
            case 'div':
                result = Primitive_Number_v_0(left.value / right.value)
            case 'mod':
                result = Primitive_Number_v_0(left.value % right.value)
            case 'floordiv':
                result = Primitive_Number_v_0(left.value // right.value)
            case 'and':
                result = Primitive_Bool_v_0(left.value & right.value)
            case 'or':
                result = Primitive_Bool_v_0(left.value | right.value)
            case 'eq':
                result = Primitive_Bool_v_0(left.value == right.value)
            case 'ne':
                result = Primitive_Bool_v_0(left.value != right.value)
            case 'lt':
                result = Primitive_Bool_v_0(left.value < right.value)
            case 'gt':
                result = Primitive_Bool_v_0(left.value > right.value)
            case 'le':
                result = Primitive_Bool_v_0(left.value <= right.value)
            case 'ge':
                result = Primitive_Bool_v_0(left.value >= right.value)
        append(result, left)
        append(result, right)
        return result

class Primitive_Bool_v_0:

    def __init__(self, value):
        self.value = value
        __vt_init__(self)

    def __repr__(self):
        return f'{self.value}'

    def __eq__(left, right):
        return left.binary(right, 'eq')

    def __ne__(left, right):
        return left.binary(right, 'ne')

    def __and__(left, right):
        return left.binary(right, 'and')

    def __or__(left, right):
        return left.binary(right, 'or')

    def binary(left, right, op):
        checkCompatibility(left, right)
        match op:
            case 'and':
                result = Primitive_Bool_v_0(left.value & right.value)
            case 'or':
                result = Primitive_Bool_v_0(left.value | right.value)
            case 'eq':
                result = Primitive_Bool_v_0(left.value == right.value)
            case 'ne':
                result = Primitive_Bool_v_0(left.value != right.value)
        append(result, left)
        append(result, right)
        return result
a = Primitive_Bool_v_0(True) != Primitive_Bool_v_0(False) == Primitive_Bool_v_0(False)
print(a)

[Execute]
None

